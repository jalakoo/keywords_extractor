- Good morning, good afternoon, good evening
wherever you are.
Thank you for joining me today.
Unfortunately, I'm flying solo today.
Alex is on holiday, but don't panic.
He is going to be back next week.
But, we continue nevertheless.
So, let's get cracking.
Of course, I always love this bit, it's my favorites bit.
So say hello in the chat.
Let me know where you're from.
What time is it there.
And we'll do a bit of a shout-out as we go along.
So welcome, welcome, welcome back to episode three
of "Discovering Aura Free."
So we had a request last week by "Fountain Hook."
Which was to look at something "chessy."
So I couldn't get the World Cup data.
So, I needed to hunt around a little bit more.
Unfortunately I run at a bit of time to look for that,
but I have found a chess date,
I have found a chess dataset.
So we're gonna have a bit of fun with that.
I'm pretty certain we're gonna come back to more chess
related stuff.
Because, I'm a bit of a chess (indistinct) I like chess.
And there's lots of fun, API is out there,
that we can go and pull information.
So we're definitely gonna come back to that
in a future episode.
But we have a "Chessy" thing to begin with.
But first of all, let's quickly go through the plan.
So I'm gonna to do a quick recap of what Neo4j Aura Free is.
So as you progress in this series, we're gonna drop this.
But, this is pretty new.
So just to remind you all what it is.
And hopefully persuade you to go and get
your free Neo4j Aura instance.
That you can join along with us too.
We're gonna pick a data set.
So this week we've picked some chess data.
So I'm gonna show you that data in a bit.
And if you've got a data set,
you want us to explore in a future episode, let us know.
So either sort of ping either me or Alex on Twitter.
So I'm @ElLazal on Twitter.
Alex is @alexandererdl on Twitter.
Or shout out in the chats, on the Twitch chat,
we're keeping an eye on that or the YouTube chat.
Or, ping it in the PR and repost.
So I'll give you address and repost.
This is where we keep all of the
previous episode information.
There are many ways, you'll figure out a way.
And what we going to do, so we've identified the dataset.
And the first thing we want to do before
we can dive into what the data model might look like.
We wanna start thinking about what kinds of questions
we might ask.
So I've got a few questions I'm going to ask
of this data that I'm gonna show you.
If you've got any questions, pop them in the chat.
And we'll pick them up as we go along.
You've all been very interactive in the past.
So let's keep that enthusiasm going.
But then based on those questions,
that's gonna help us figure out what the data model
is going to be.
And then using that data model,
we are then gonna go off and load data
into an Neo4j Aura Free instance.
And ask those questions.
So very quickly, what is Neo4j Aura?
It is Neo4j's database as a service offering.
So it's on the cloud.
It's a managed service with elasticity,
all those good things.
And it's managed graph infrastructure.
And what Aura does for you,
it will keep the database up-to-date
as new versions come in.
That's all handled by Aura.
It will manage backups for you as well.
And it provides continuous uptime,
and overseas monitoring as well.
So all of that good stuff you would expect
from a cloud service.
So if you want to find out more, you've got the link there.
So what's Neo4j Aura Free?
It's a free version of Neo4j Aura.
So you've got some limitations in there.
So you're limited to 50,000 nodes,
and 175,000 relationships.
But that is more than plenty to work with
for a lot of scenarios.
And as you've seen with our series.
We creatively truncate the data,
if it's a very, very large data set
to be able to fit into those sets.
You still got access to Neo4j Bloom and Browser.
So we haven't used Neo4j Bloom yet.
But will over play one of our feature series
where we can show you how to explore the data.
But obviously we use Browser a lot.
It's free forever.
And if you want to get to the landing page,
again you can use the same address.
And you'll have an option there to select the free instance.
So we're gonna get going now.
We're gonna have a bit of fun here.
This is gonna require a bit of creative thinking,
but it's good fun.
And this week data set, I had a quick search on GitHub.
So what's really nice about the sessions we do here is
we always go for data set where we can pull it
from a URI somewhere.
So that we don't have to worry about downloading that data
and uploading it somewhere.
This makes it like really low friction with regards
to being able to pull stuff.
And I just did a quick search on GitHub.
Looking for chess data that was in a CSV format.
And I bumped into this rather interesting dataset.
So it's a Caruana-Carlsen game.
And what Zaid Qureshi has done
is he's taken that, and he split that.
So I'm gonna show in a second.
So, I've pulled it out from Zaid's,
GitHub repository, big shout out to him.
Thank you very much for having that.
So I will ping the link as well to that repost
over in the chat as well.
If you're joining along,
I'll probably give you the full one.
So I've done the short one there for those of you
are catching up on the video, so you can see it.
So that's what we're gonna look at.
So let's go have a look at that dataset.
So this is the data setting question.
Let me ping over the GitHub link in the chat.
And what's interesting about this,
and there's a bit of it.
It rolls over to another page.
But I think these are probably the columns
that we're interested in.
So this is all the same game.
So you've got yourself ID here.
I haven't dug into seeing the game.
I'm gonna guess here based on,
did we get a date for this game?
We'll have a look in a second,
we'll look at the Raw CSV.
But we've got in here,
we have got the, so it got moved.
Number 5 is the same game.
So we've got the name thing.
So move number pairs obviously in chess.
We've got the move number pairs typically
when we're recording a game of chess.
Obviously each person has moved.
So these are almost like your half moves.
So this move number is like a half move number,
it's obviously (indistinct) so soon.
Caruana has played e4.
The black move, so Carlsen replied with a c5.
Obviously looking like a Sicilian here
for those of you who follow opening theory of chess.
And so we've got here the first bits of information.
So we've got the move numbers.
That's like the half move.
We've got the move number pairs.
Obviously we like two of those.
Because white plays the move, and then black plays the move.
We have got the notation.
So this is like the abbreviated algebraic notations.
That say a way of writing chess moves.
And here we've got the full move.
So the abbreviated notation gives you
the minimum amount of information required
to go off and do move.
Whereas the full algebraic notation tells you
what was the original location of a piece
before it moved and where it moved.
And we're gonna move 2,
so that's why we've got e2, e4.
From square, so obviously this is splitting out
the full notation even further.
So from square e2 to square e4.
It says what piece moves,
so this is gonna be really cool for us.
I've already got some ideas forming in my head,
the kinds of fun questions they're gonna ask.
So what piece moves to here, we know it was a pawn.
So we've got a lower, is this capital?
I think is a capital, isn't it?
You got capital P to indicate either capital location,
we'll figure it out when we pull the data in
and have a look.
So we've got here to indicate what moves.
So we know here is a pawn.
And then obviously later on,
so obviously you've got some sorts of open
Sicilian game going on here.
So knight f3.
So here we know a knight moved.
You've got the color.
So who was moving.
And then we've got FEN.
So what's FEN, FEN is another kind of chess notation.
And what FEN tells us is that
at any given time this tells us what was
the position of the board.
So this is a really, this is quite a neat way
of being able to tell us what state the board looks like.
So here, everything in lowercase indicates black.
And with FEN notation, you always work
from the eighth rank down to the first rank.
So this is obviously, these are all the black pieces,
obviously what's moved.
So all of the black pieces will be in their home place.
If there's an 8.
That means there's no pieces in that rank.
Obviously, if you think about it chess board set ups,
yes we said we expect 8, expect 8.
So nothing in there.
We know that Caruana moved pawn to e4.
So here we go.
So what we say here, so here we split it up.
So the next is 4, it basically means if you move across 4
those will empty spaces.
And then on the fifth space, there means
there was pawn, which would expect from pawn to e4.
I should have put up a chess board to talk this through.
But, keep with me.
It's all good, it's all good.
Then three empty spaces, and the next rank in terms of.
So FEN is a really nice way of doing that.
Which then pops another idea into my head
that we can go from Caruana, have a bit of fun with.
So there's a load more.
So if I just quickly switch over to the raw data set.
So you can see here, this is what we talked about.
So we've got loads, loads and loads of fields.
Cause if I pop here, and it's gonna look nicer
when I clear into Neo4j.
So maybe I will do that in a second,
so we can see what's going on.
But you see we've got a bunch of fields.
So let me do that now.
So that it looks, it's a bit easier to see
what's going on here.
Cause it can be a bit hard in this.
So I'm gonna jump over to here.
And then do, load CSV with header from a link
as row and return row limit 5.
So we're not loading anything into the database.
We're literally just pulling a copy of the CSV.
So we're downloading a copy, and then having a look
at what's going on.
So you can see here, there's been a lot of split out
of the FEN.
So he's basically split out each of the rows.
So this value here, what it looks like to me,
what's going on and we can quick check here.
It sort of confirms my theory.
Is, what he's doing here for each row,
which is adding up the value of the pieces.
So in chess, if you're not familiar.
Each of the pieces has a value.
And convention states that rooks worth five points
and knights worth three.
Bishop is also worth three.
Queens worth nine.
king is priceless.
You wanna keep that one.
Otherwise the game is a bit, a bit gum, and so forth.
So if we very quickly tot up what's going on.
So you've got 10, 16, 32 plus the queen.
(gasps)
Hello.
Hang on.
So, 8, 11, oh no, I can't add.
That's what's gone wrong.
So 11 times 22 plus the queen, 31.
So that's value pawns are worth a point each.
So that's 8.
So he's basically taken each FEN row
and put in the value of each of those.
Okay, right.
It's checkmate, it's obviously got flagged there.
FEN row, black value.
Yep we know that.
We're expecting all of FEN row one black value are.
So he's doing it by, he's also totting up predominately
from the blacks perspective and white perspective.
So I assume there's some interesting application
where this is probably gonna be set in
some kind of chess engines.
So maybe that's the purpose of the CSV here.
And then you got another, a lot of interesting things here.
So, if 50 moves.
That's an interesting one.
So I assume that's referring to the 50 move rule.
Which could be a question we might be able to ask.
We'll have a look.
2 square, okay.
So that's, we looked at before.
So that's where this square is going.
Is five fold repetition.
So that's interesting.
Cause it should be threefold repetition.
So very, very quickly in chess.
There's a number of ways you can get a draw.
So you can get a draw by agreeing to draw
with you're opponents.
So you offer a draw, they accept.
Then you've got a draw.
Another way you can get a draw is through stalemate.
So if a move is made so that the opponent
can not make a legal move, that's a stalemate.
So that's another way you can draw.
A third way you can draw is if your, if you run out of time
but your opponent's got no material
with which to create a checkmate against you.
That's another way you can draw.
And another way you can draw is this idea of 50 moves.
So if you make 50 moves, so not the half moves,
the full moves.
So if you both make 50 moves and a pawn
and a capture never happens.
That's another thing you can claim a draw on that.
Which is why chess players row their moves down.
So they can see if that happens.
And another way you can draw is this idea
of free folds repetition.
So if the position repeats itself on the board three times.
Then you can claim a draw on that.
And that might be one of the questions
we might ask for more data.
So you get the idea.
Most of this data we're going to ignore.
And I think the bits that really are interesting
for me here, if we pop back to this one here.
Is I think, game idea we're not worried about.
Because we all know that's from the same game.
This should be very useful if we stopped bringing
in other games.
And maybe that's going to be an episode,
I want for another episode in the future.
But, so you've got the ID.
So the things we've seen, move ID.
Yeah, that's the move number.
That's gonna be interesting.
So we can decide which one we want to do.
So we can either go with this one.
And go, if it's odd, we know it's white.
If it's even, we know it's black.
Maybe we're gonna just stick with that.
And then we figure out how can split out the black move.
I don't think we need to worry about players.
Because we know that Caruana is white and Carlsen is black.
This is where it gets interesting now.
So the other stuff now is, do we wanna capture moves?
Maybe that might be interesting.
I think we're gonna capture the pieces.
And I'll talk about why my thinking is there.
We probably don't need to worry about white and black.
And the FEN, I think is going to be quite interesting.
So that's a quick sort of whistle-stop tour of our data.
So, what questions do you want to ask of this data,
so pop them into the chat.
And I'm gonna talk about some of the things
that jumped in my head when I looked at this dataset.
So, the things that I was looking at this,
and I thought will be interesting would be.
I definitely wanna capture the FEN as a node.
So I want to capture this information,
I want to store the FEN as a node.
Because what, this will allow us to do,
it will allow us to, if I treat this as a unique thing,
so I wanna keep this distinct value here.
And we can very easily see if a position
has repeated itself.
And I'd be quite keen to see as well
what was the move number when the position repeated itself.
So that's something I want to ask.
So I'm gonna just juke down that question for myself.
So I want to know, how many times this position repeat
or has a position repeated.
And when did it repeat.
Another question that jumps up,
I think will be a bit of fun.
Would be to have a look at what pieces we use most often
both for black and for white and overall across the games.
So I think that's a bit of silliness there.
So how often was a piece used?
And, have a bit of fun, funness I think.
Would be to see how, what's the most popular 2 square.
I think that might be interesting as well.
Maybe, I think that might be interesting
to see what piece comes to that square.
So, yeah, okay.
So let's start thinking about,
so if you've got any suggested questions
you want to ask.
Pop them in the chat.
But what I'm gonna do, is I'm just gonna start
having a think about what this data model
is gonna look like.
So let's bring up "arrows" our good friend.
So if you're joining in with arrows, here is a link.
To have a play as well.
So, we said FEN.
So let's, and we go with the easy one.
Cause this one's gonna be interesting.
So I don't think it's gonna be obvious,
what this looks like.
So you put value.
And, oh goodness.
This is gonna be a real sort of mind-boggler isn't it?
So I think we've got this concept of a move haven't we?
Let's put in a move.
And, gonna have a number, there is a number.
And, let's put the position.
And move is gonna be the, this one.
And the reason why I'm using this one for the move
is because we can basically chop this up.
So if I want to ask the question about the
popular destination square we can.
Okay.
So we've got move, results in.
Position, goodness me.
Has position.
So we move how to position FEN.
So that's, actually let me just change that.
I will just call this FEN.
Here we go, it makes a bit of sense.
Position, has moved FEN.
So what else did we want to ask our questions?
We had, how often does a position repeat
and when is that, we just look here.
And then we'd count the number of relationships
coming off there.
How often,
(gasps)
how often was the piece used?
Oh yes, yes, yes.
So where do we want to put that?
Lets put a node in.
It looks something like this, maybe.
Let's just check what happens,
if we've got something like this.
So I probably might get rid of this relationship here.
I'm just gonna talk through the rationale here.
So what have we got?
So, we said we wanted to,
let me just bring up my notes.
So we said, how many times did the position repeat and when?
So we could do that by, no we can't do that.
Can we like this, oh no we can.
We can, we can.
Cause what we do is we just have a long relationship here,
so it would infer via this.
So what we would do here is we'd count the number of moves.
And then that will tell us how often the position repeats.
That's okay.
How often was the piece used.
We can do that via here.
So we can count how often the piece was used.
And then we can infer whether, we can split out
by players based on the move number.
So we can do the odds and evens.
And that can tell us.
And, I'm going to cheat slightly.
And let's put an extra property on here.
Let's put in color.
So that can tell us move color it was.
Okay, cool.
What is the most popular square?
We can do that via here.
And we can just take the move
and truncate the back to square.
So I think that does everything.
So gonna get rid of this.
There'll be many ways we could have done this model.
And there's probably a more efficient way of doing it.
But I think for now this answers all of our questions.
So we've got all information from
wants to play out this game again.
We can do that.
And oh yeah, I wanted to ask,
(gasps)
good question.
Oh, good comment by BennuFire.
So the thing here is as BennuFire has
just pointed that in the chat.
So let me just pop that up.
Is, the challenge here is if we wanted to know
about a unique piece.
So if we wanted to know,
cause obviously you get two knights each,
you get two bishops each, you get eight pawns each,
that kind of thing.
So whilst we know by type of piece and filter by color.
We're not necessarily going to know by unique pieces.
So, I like how you think BennuFire, I really do.
So let's think about, so what I'm gonna do for now is
I'm going to cheat slightly.
And I'm gonna skip that one for now.
But I do like that question.
And I'm gonna have a little think in the background.
So I'm quite keen to get some data in and do it.
And then let's come back and see what could we do
to iterate that model.
So that we can look at unique pieces.
So we can do this.
And what we could do to adjust this model
would be for each starting position.
Presumably that's what we could do.
So we could chain it by the position
of where that piece moves.
So let's have a think about,
let's have a think about for now how we do that.
So I'm gonna put that down as a question.
So I think that's a great question.
And I don't think that's something people
tend to think about in chess analysis.
So with bishops, it's slightly different.
Because obviously they're in different colored squares.
So that's quite straight forward.
But things like pawns or rooks or knights,
I love that question.
So I'm gonna drop that down.
And if we don't get to it today,
I definitely want to revisit that.
Because I think that's a nice, nice thinking there.
So how to track individual pieces,
I love that so much.
Right, and everyone we had was,
what was the most popular square, we can do that one.
And now what I wanted to do was count for
three for repetition.
So did, or how many, no we've done that.
How many times the position repeats.
Okay, brilliant.
So we gonna do that.
And, I'm just gonna quickly indulge myself
in Bennu's question there.
Which is, what might we do to track individual pieces?
So what we'd probably do is,
actually no.
I need to think about that.
I can't think off the top of my head how to do that.
But that is a great comment.
And we'll come back to that.
So here's the data model for now.
So let's work with this.
And let's get some data in.
So, what we need?
So we're gonna do the FEN, the move, the piece.
So we're gonna be using merge.
So we'll merge on the piece type,
we'll merge in the position.
And these are going to be creates.
Because we know those exist.
So I'm gonna have to remind,
so actually no, I can cheat.
Cause we're gonna have the number, move and color.
So that's all good.
Right, so let's do this.
So we have got our loads.
Let's just make it a bit smaller.
And, let's do the following.
So we know there's less than 50,000 knights.
We don't have to worry about doing any kind of threshold
thing or anything like that.
So let's do a merge, position P, position,
FEN, and that's going to be row.
I think it was just FEN.
Let's just double check.
Oh yeah, row.FEN.
There you go, that's handy.
So it's right there.
So doing a merge on that.
We're gonna do a merge on the piece.
And that's going to be type,
and I think row.- what did we say piece was?
I like this.
Then we got piece.
And then we're gonna do a create a move.
Move.
Move.
And in there we've got the move.
And that was FEN, actually that was row.move.
We had the color, which we've got in there.
So I am going to use my English spelling.
Sorry to be a US folk who will be tuning in later
to watch this.
So I've got color.
And what else did we say we wanted in there?
We wanted move number, oh yeah.
That's a handy one to have.
So that's gonna be number.
And we had a few of these, didn't we?
So I think what we can do is we can go with the move
no pair, that was right, wasn't it?
That's the one where we move no pair.
Oh no, yeah move no pair.
That's what we will.
So let's do that.
Wrong window.
So move.
No, what's going on here?
No, as we know all of these will come back in strings.
So I'm just gonna cause that to interject.
So let's do two integer, and just wrap that in.
Okay, so created those.
And then we need to hook them all together.
So let's do with P piece m.
And then we're gonna do,
(gasps)
cause we've to got create for this one.
What we can do here is we can create a relationship
between here and here.
Because we know all of those are going to be unique.
And that's the fastest thing to do.
But here we're going to do a merge.
Because it could be a situation where a piece moves.
I mean, with the repeated position.
But other pieces could move.
So those two are gonna merge.
If that makes sense.
And hopefully I can just do this in one go.
If not, we'll just split out the query.
So we're gonna do 8, move, and what did we say?
Move involves a piece.
And then we're gonna do merge, piece.
Results in.
Position.
All right, okay.
So, let's see what happens.
Put the data in.
Oh, that was quick.
All right, let's have a look at this.
It looks like, we're gonna do match
and return star.
That's interesting.
Of course we would expect this.
So the only thing we don't really have at the moment
is we're not really connecting all the moves up.
But that's okay.
We can sort that out later.
So that's, let me write a note to myself.
Is how do we, so I think when we start
tracking individual pieces.
This is when things will start to connect up at the moment.
But for now we've probably got a bunch of little splinter
graphs based around to different pieces.
But that's okay.
So just straight away, what's jumped up to me
is a fun thing here.
Is do different pieces.
Moving result in the same graph.
Oh, we might jump into Bloom for this.
This might be a bit of fun.
So let's quickly go and answer some of the questions first.
No, I'm gonna jump into Bloom.
I'm all over the place.
But it's fun.
It's fun.
So let me just quickly log into Bloom.
And I'll just talk through what I was gonna look at.
So Neo4j.
And my password.
So, the interesting thing that just quickly,
that jumps up here.
So you notice how we gonna have these little islands.
So if I bring up some more pieces,
let me show you what I mean.
So if I just minimize this window,
so what we're gonna find here, if I bring back pieces.
So obviously we're gonna have six pieces,
six different types of pieces.
And if I double click on these,
and what you'll notice is that they're
just gonna be like little globes.
So let me just minimize this a bit.
So you're gonna have these little globes, which makes sense.
Because we're not connecting the rest of the game together.
So what I'm curious about here is,
does a situation arise where two different pieces moving
result in the same FEN position.
So that's me popping all of that.
So you can see we've just got our little globes,
like little islands.
So let's go and see what happens when, in Bloom.
Does it ever happen that we have piece position piece?
Nope.
So that doesn't happen.
So we can rewrite that query out in Browser as well.
Let's do match, P piece.
Result in a position.
And I wanna know about P 2.
Gonna check and see if different pieces result
in the same position.
So let's do pos, return pos.
Oh, hello.
So, okay.
This is, lets return star.
I think maybe, here we go.
Now this is interesting.
So what this is telling us here.
So it may be this, may be for Bloom,
obviously isn't necessarily gonna,
most efficient cipher created here.
So what we're saying here, which is very exciting.
Is that what's happened is that
there's been three occurrences where either
a rook moved or a king moved.
And it resulted in the same position.
Are these the same?
Oh no.
They're three.
So they're three different positions.
But when you see the thing here,
is that's happened to,
what's happened is that they've come in different places.
And what's happened is that you've moved different pieces,
but the results in same position.
So the other thing, if you remember one of our questions
that we had.
Was, how many positions have repeated more than once.
So straight off the back here.
We can say that at least three games resulted.
But obviously the situation may happen
where the same pieces moved.
So we're gonna have a look at that.
And, Tamash has just asked what does he need to do
to get a 1700 rating?
Lots of practice, and dedication
and determination and reading books.
Playing lots of games and looking over your games.
I don't think my efforts here in the graph
are gonna help with that.
But so good.
Ah, right.
Okay, cool.
So that's that.
So a little diversion there.
So I'm gonna copy this.
Cause I think that's a really fun query.
But let's have a look at answering the first question.
Which is how often did a position repeat,
and what was the position?
So I'm gonna recycle this query.
And what we're going to do here is,
I want to put in, so I need to do is repeat
the whole sequence.
So remember, we said we've got a merge here.
So that something could have happened several times.
But we don't know.
Because if it was identical between these two,
then it's gonna be there.
So what we need to do is we need to include
this entire path.
So let's have a look at that.
So let's do match, we've got a move,
which is used a piece.
I'm keeping those, something was going on.
It resulted in a position, position.
Okay.
And then what we're gonna do is we want to count
the number of times that move resulted
in the same position.
So what we're gonna to do is we're going to return,
actually with position.
And with collect, there is that, collect
m as moves.
Return position, lets do, return position
and size, isn't?
Size moves as size order by size descending, right.
Oh, hello.
What's going on here?
This is not what I was expecting.
Are we seriously saying that this came back.
(gasps)
This does not make sense.
So, let's see what's going on here.
Let's just quickly do this.
This has caught me by surprise, I have to say.
Return labels (n) count (n).
And this should hopefully tell us what we've got.
So we have got 229 moves.
That sounds like a lot of moves to me.
Have we got more than one game in here.
And I've jumped the gun a bit slightly.
Let me just quickly check this.
Yeah, right.
Return distinct row.- what did we say it was called?
We said it was called game ID.
Oops, wrong one.
No, it's the pawn game.
So how many moves did it go down to?
I don't know.
They did actually have 150 moves.
Well, that was a long game.
My goodness.
Well, they had a rook, they had a pawn, pawn,
king, pawn, king.
Okay.
Rook and pawn ending.
Okay.
Pop out of here.
Okay, so that makes sense.
They did have that many moves.
So, let's look at the one that didn't repeat so often.
So you've got this one.
Which apparently repeated 14 times.
Something suspicious is going on here.
What I'm gonna quickly do,
I'm just trying to think what's going on here.
So what's happening here is
we're using this as a branch.
Now what could be happening as well is that
we could have different pieces coming
into the same position.
But that shouldn't be a problem.
Because, so that would double what's going on.
So we know we have those three instances
where rook and a king move results in the same position.
But that's only three of the things where that's happening.
So next question here is, do we have a duplicate move nodes?
Let's just quickly bring those out.
Wrong one.
So let's do match, move,
return m.no, m.color, m.move order by m.no.
Now that all looks sensible to me.
Yeah, okay.
Wow.
This one's real interesting.
So, I'm now curious if there's something going on
in the, in here.
So let's bring back some of these.
Cause I'm now very much intrigued.
So I'm just gonna close all of these up until here.
I'm gonna go back to one of the other questions.
Cause obviously we're spending a lot of time on this.
Cause I'm quite keen to do the,
how often was the piece used question.
So, moves limit 1.
And then let's return star.
And let's see what comes back.
So, I'll just grab a copy of this.
Lets see, turn star and let's see what comes back.
So we have got, so 54 move 1, this is interesting.
So it's saying that move 1, okay.
I see what's happening now.
Because it's going via the pawn.
So this is going via the number of moves.
So we do in fact need to have this relationship
between moves and position.
So that's what's gone wrong.
Which is all good.
We can just, so you may need to rethink
what does this part of the model looks like.
But that's fine.
So we'll reload the data quickly.
And put that in.
So that's like two second jobs.
So, I'm just gonna do that now,
I can just, delete all that.
And then just quickly pop in this.
And then let's do, oh no, I didn't mean to do that.
Don't buy a cheap blue tooth key board.
It might top-tip.
So let's do create involves piece.
Let's do a create move, results in P.
We drop into position.
Right, okay.
All fixed.
So now very quickly, let's go back to this question.
I'm just gonna recycle this.
So what you're saying here, this is going to be, oh dear.
That's fine, it's all good.
It's probably, I should have picked a different
relationship type.
But that's okay.
So, right.
If we now do with position collect m as moves, return that.
Okay.
Still not quite, cause I did the limit 1, didn't I?
There we go.
There we go, problem solved.
It's all been fixed.
So you can see now these are all the positions
where they've repeated twice.
So there was no free fold repetition in the game.
As you can see, there was no free fold repetition.
The positions at most repeated twice.
And these are all the positions that repeated twice.
There we go.
And then obviously the rest of those can be repeated once.
So what we could have done is we could have put in
a WHERE clause.
To say where it's greater than one.
So let's just quickly do that.
So I think I can do that here, can't I?
Where size is greater than 1.
Put in the wrong place.
It's just the guessing game of trying
to remember where to put this in.
So I probably have to do it up here.
There we go.
So this now pulls back all of the positions
that were repeated more than once.
Brilliant, okay.
So next question was.
How often was the piece used?
So Bennu's comment aside about being able to
obviously track individual pieces.
I love that question.
So we'll have a look at that in the future.
I think that is stellar.
But let's do this quickly.
So we're gonna do match move.
And we know there is a piece involved here, piece.
And lets do return, P.type.
So it's gonna tell us the piece of type.
And then we want to collect moves don't we?
So lets do, with P collect.
M as moves.
Then lets do return p.type.
And size moves.
As size order, by size descending.
No, I'm surprised.
I was expecting the pawns to be the most
frequently moving pieces.
But it turns out, the top,
the rooks were moved the most number of times in this game
followed by the king.
So that's interesting.
So kings tend to be very active.
If you get into the end game of a chess game.
They become very powerful pieces.
So once the queens are off the board,
you tend to see the kings being a lot more
mobile and active.
So the kings moved 46 times.
And then it was the pawns.
So that was a bit of a surprise.
I was expecting the pawns to have moved the most.
But that was not to be.
Another question we had was.
What is the most popular square?
So similar theme as well.
Here I think we're just gonna use the move node.
So match, move.
Want to do right.
With right and . move and 2 as destination.
Return destination, count destination as c,
order by c descending.
So what's the most population destination square?
C3.
So c3 on the board.
So for those of you, you're not quite sure.
So they're basically the,
move notation works where the letters,
those go across the boards.
It goes from A to H.
And then the numbers go from 1 to 8 vertically.
So c3 is along the corridor of 3, up the stairs 3.
So that square was the most popular destination
for pieces to go.
And what's really fascinating here as well,
for those of you who are a bit on the chess side,
is interestingly you would probably expect
lots of activity to be towards the middle of the board.
So anything between sort of c3, f3, f6, c6.
So that kind of thing in there.
We're kind of seeing that.
So here, here, here, here.
So you can see that all of these,
those are the most, typically the most commonly
active squares.
So this g7 is quite interesting.
So I'm curious for looking again,
did we see that the king moved back and forth there.
So that was really cool and fun.
And what we could have done to elaborate is further,
is we could have done square and piece.
Is there like a popular square that piece went on to?
So that's that one.
So that's the, and we think we've got, yeah.
So those are the three questions that I had.
We've got 11 minutes left.
So let's see if we can try and solve Bennu's one,
which is about how do we track individual pieces.
So let's go back to our data model.
So here, what would change slightly,
is would have a, we'd have the individual piece.
Great.
Now again, if you've got any thoughts on the stream,
do try me on the chat.
I'm keeping an eye.
And let's have a look at what we can do here.
So think this kind of, we're probably gonna
change it slightly.
Where it's got type and maybe we'd add a value like origin.
So this has been the origin position.
Actually what I'm gonna do is, I want to duplicate this.
So do I get an option to, no I'll just,
I'll try remind myself.
So I'm gonna do here is
I'm just gonna shuffle this up a bit.
Oh, it starts completely pointless.
Cause it would just reject everything.
So never mind.
But let's, can I take all of this,
and can I duplicate?
I can duplicate.
Look at that, that's handy, right?
So let's go in and have a look at this.
So here we'd probably have a origin,
which is where we put the origin square.
So that's how we can track what piece it is.
Because it has an original position.
And let's sort of think about how do we follow it through.
What we could do, and this is massively "hacky."
And I'm sure there's better ways of doing this.
And I think if I spend some time, I can figure out.
But what we could do is every time we bring in a new move,
yes Bennu exactly.
Yes, grabbing one's head.
So a slightly "hacky" thing we might be able to do.
If we come back to this.
So remember we've got, the nice thing about
this move notation.
Is it tells us what was the origin square for that piece.
And then where did it move to next.
So what we might be able to do, I'm gonna have fun time
trying to think about the cipher career for this.
But what we could do, is every time a piece moves
is we can use this to search for the origin square.
I actually, I'm gonna change that to current square.
And then that's the piece we've match.
And then update it.
So could we do something like this?
Actually I'm gonna change it.
It's not gonna be origin.
Get rid of this.
I love this.
I love your question, Bennu.
Cause I'm now totally psyched about solving this.
This is gonna be location.
And that's gonna be the pieces current location
on the board.
So this is how we're going to be able to track everything.
So what we can do here is we could do some kind of a rule.
Where we can do something like,
if a piece at this location,
so if a piece that doesn't match e2, it doesn't exist.
We create a new node.
And if it does exist, then we update it.
If that makes sense.
So, gonna have to have a think about how
we write this query.
But I love this question.
I think this is amazing.
So, we're gonna get rid of all the data again.
And, cause I think we can still answer the questions
about which was the most popular piece.
Cause we've got the piece types.
The thing we're adding now is the location.
So let's think this through.
Okay, so, oh my goodness.
So what we're gonna do, we're gonna do merge.
So we don't do a emerge.
We're gonna do some kind of a,
so let me write out the pseudocode for where I'm thinking.
Cause it's this line here we want to change.
So we wanna do something along the lines of,
if, oh on we have to do it on the piece.
Don't worry, the position is fine.
We're gonna do something about this.
We're gonna say, if piece and,
if piece equals piece and location equals left,
move 2, then continue.
But update location, right move 2.
With me so far hopefully.
Otherwise we want to create a merge
or what we're gonna do otherwise,
we want to, otherwise create,
go on and to live life on the edge of create.
And then it's gonna be piece equals piece.
Piece equals piece.
And right move 2.
So, right.
Bennu has asked, are you planning to keep track
of the actual square or recursively track
the squares visited and venture calculated lost path?
Yeah, no I'm not doing the last bit.
That Bennu is for another episode, although I do love that.
I don't really want to do that, we could do that.
We could have like a little path couldn't we?
Where we just see where it goes.
(gasps)
I do like that.
I've definitely have to come back to that one.
Cause that's gonna need a little bit more thoughtful,
model thinking.
I'm just doing a "cheaty" hack that we just know
where the pieces went.
But I guess we could reconstruct.
Even with the "cheaty" hack.
I'll talk through how we can do that.
So the "cheaty" hack we can revisit it.'
Because we have these two nodes.
And we always know this node comes back.
So we can always reconstitute, and it's a bit messy.
But we can always cycle back and forth through these ones
to find out the journey of that piece.
So we do have options to reconstitute that.
Okay, right.
So let's just check this logic here.
So we're saying if the pieces row.piece
and the location is row.left move, so if it already exists.
And now it's saying that it goes up,
then what we're gonna do is we're gonna update the location.
But we don't need to create a new node.
Both if it doesn't exist, then we need to create
a new node and move right.
So, I guess we could do a merge on this couldn't we?
And we could like, on create on set.
So can we do that?
So let's give this a go.
So on piece and let's do a, location is,
no we can't do that.
Oh no, oh actually, yeah we can.
On create set piece.location, no we can't.
We got a question from Digby Knight.
I just realized I can't do this, what I'm doing here.
But it's all good.
A quick question.
I'm not forgetting your question Bennu.
So quick question by Digby is,
if when the data science library will be usable in Aura?
So it's coming very soon.
So the GDS library will not be available on Aura Free.
But it will be available on Aura Professional.
It's coming soon.
Keep your eyes peeled.
It's coming soon.
Well keep an eye on all your various channels and things.
And I'll give it a shout out on here as well
when it's available.
You do have GDS available in our Sandbox
as well available now.
So it's available in the Blank Sandbox,
it's available in the Street Mope Sandbox,
it's available in the Data Science Sandbox.
So you can use it now in a cloud type environment,
which is the Sandbox.
And the Sandbox does last up to a maximum of 10 days
if you need to do it.
But it will be available in Aura Professional soon.
So keep your eyes peeled for that, and you will see it.
So right.
Let's go back to this hacky, hacky query.
So I don't think we can do this.
So I think we need to do,
I'm just trying to figure out how we do this.
What we can do, we take it from,
actually no we can't do that either.
Oh my goodness.
Can we do a merge on the start position?
Ah yeah, we can.
So what we could do, is we could do a merge on this
and then on match, we set the new source.
Oh yeah, I like this.
Let's do this, let's do this.
I'm feeling good about this.
So let's do merge, row, piece
and location is row, gonna be left.
No, I think we want to do the, we won't do right don't we?
Oh no, that didn't work either.
Because what we wanted to do,
cause it's always gonna be new.
So I think we do need to have some kind of a,
a statement here.
I'm just trying to figure out how we can do this.
I'm not sure we're gonna have to solve in this minute.
But I'm gonna keep plugging away at this.
Oh my goodness.
Right.
So I think this is, this is, right.
So what we're going to do is,
cause when this happens.
All we wanna do is just update the location.
If this doesn't exist, then we want to create the piece
with a new location.
Now the problem is, is if we do it on,
we're only going to do one path, aren't we?
So you imagine here, it's gonna create this.
(gasps)
No, we can do this.
We can do, no, no, this is fine.
So I think we're right to begin with.
So what we can do is merge piece, location, left.
And then we just do it, left row.move 2.
And then we say, if it's on create,
so if we're creating it for the first time,
then we're gonna change the location to right, row move 2.
And if it already exists on match,
you do exactly same query.
I think that's gonna work.
I hope, there goes nothing.
All right, let's see if we've answered this.
I'm sorry we're running a little bit late.
But I feel we need to, let's see if this works.
So let's see how many pieces we've got.
Let's do, so we should have 32 pieces if this worked.
So let's match and return labels and count, star.
Oh, okay.
Something went wrong here.
Cause we've got 144 pieces.
We shouldn't have 144 pieces.
So, did I forget to clean the database first.
Oh, that should make a difference.
Still shouldn't have 144 pieces.
So something's gone horribly wrong here.
Let's give it a few more minutes.
For those of you who can hang around,
otherwise just catch it up on the recording.
And just quickly before you go.
So I will upload later on today.
I will do right to upload the session.
So for those of you, you have to disappear.
There's a link you can catch up, if you have to go now.
I'm keen to fix this.
So let's just quickly check what's going through.
Lets walk through the logic here.
So we are saying, match, row piece.
That's going to be the name and its location.
So that's going to be left.
Yes.
So if we're creating it, we're gonna update
the piece location to the next two.
That's right.
And if we're merging it, if we're matching it,
we're updating it.
So let's walk through this.
So what we're saying is we would merge p and e2.
And then if we're creating it,
we then would update the move to the location to e4.
And if there was like an e4, e5.
I think the one thing where we're coming (indistinct)
as well, so I think I might have to park this for now.
I suspect the problem here is also happening.
Cause we're looking at this, move color independent.
So what happens if for example, cause e4
get captured at some point.
So that's some quick peak,
no where's my little scroll bar.
My scroll bar has disappeared.
It's a disaster.
So lets do e4, e5.
Okay, there you go.
So e4, e5, that happens at some point.
So that's great.
But I assume something may happen like this e5, e6,
okay pawn E47, my goodness, that pawn travels far.
But something may happen to that pawn at some point.
So maybe it gets captured.
And then that probably, yeah.
Here you go look, f5, e7.
So something's captured f6, there you go.
So f6, e7.
So that was a bishop.
So bishops captured that pawn.
And then that's probably registered as in you,
that's probably registered as a new piece, maybe?
No.
I need to think this through.
So I won't forget about this.
I think this is a great question.
So we answered our main questions.
Which was the, which was,
how many times did a position repeat,
and when how often was a piece used.
And how popular is a square.
So we did all of that.
And let's figure out how we can track the individual pieces.
I'll have a bit of a think about that.
And I will write it up in the GitHub repository.
So apart from that, thank you very much
for joining me today.
I hope you had fun.
If you've got any datasets to suggest,
you have a number of ways of doing it.
So ping me on Twitter.
So my handle is @ElLazal.
So I'll just walk right back into this chat.
You also raise a PR on the repost.
So you've got the address to repost there,
raise that as well.
And we've got a music e-dataset.
Which has been suggested.
So we will cover that one next episode.
If you've got any other ideas, chuck them in.
We'll look at those.
And otherwise, thank you for joining me.
Alex will be back with me next week.
I hope you have a fabulous rest of your day,
and see you later.