hello and welcome
and well good morning good afternoon
good evening hi michael nice to have you
again
on on our session
um
yeah i i i'm looking forward to this one
so this is this is the second one we are
doing together on on aura3
um
so this is this is the
the one hour show basically where we go
into aura free pick a data set and go a
little bit into
how quickly and easy it is for everybody
to get started but you know before we
dive in maybe
um
tell us a little bit where you're from
um in chat um what you're doing at the
moment is this your lunch break um is
this your early afternoon tea break is
this uh
uh is this uh dinner or are you are you
watching us at 3am because you
you you can't sleep
we have some of those folks that were
watching like
super early in the morning like 2 a.m or
3 a.m because they're like night
night hours like that was totally yeah
but today probably we should have some
more folks from the u.s right
yeah this is this is later exactly we
changed the format a little bit yeah
to uh every other week we do an
earlier morning morning session uh
european time and one we do a later
afternoon session
um
for us in europe so that means uh
different different uh people should be
should be
more able to attend at least
yeah um
from what you're doing and
really looking forward to see some
feedback from folks
exactly
while you type away i'll i'll give us a
quick um a quick overview of what's
what's going on and what what the the
plan is is for today
um
so yeah like like i said um
the plan is a little bit to to do a
quick uh a quick recap of what is neo4j
or free i will i will do that in a
second
uh give you a a short overview of what
what what orafree delivers
um
but the the core of the session will be
that we pick a data set and we pick a
different one every time or we try to
pick a different one every time
if you have a data set you you think is
interesting you you would like to
explore but maybe you don't know how or
you think it would be cool if michael
and i would do it
um then give us a sh give us a ping you
can type it in chat you can send us a
tweet you can
ping us on discord um
there are there are various ways to
reach out and if you have um if you have
something you would like to to to look
at uh together with us then then let us
know um and we we're happy to do so um
in one of the next uh sessions
um
once we pick the the data set we will
kind of explore a little bit in in
modeling land and see where we where we
go and what what kind of questions we
would like to ask where would we what
would we like to know out of the data we
have
and then obviously how would we model
that
depending on the on the questions which
we which we would like to solve
um
and then we load and query
and uh and import data and get it going
and then have some some fun with it in
neo4j aura
this is this is the plan for today
and this is what we do uh i'm looking
forward to it
you know quickly um or free what what is
it and and
what uh what can you expect so it's a
completely free version of neo4j aura so
this means
when you type in uh neo4j or free go to
our website in twitch you can use
exclamation mark aura and you get a link
directly i'll put it in chat in a second
um
you can you can um you get one one
instance for for free for you and it
it's for you with you for forever
basically so that's maybe the the major
difference so to speak between
between sandbox and aura free or free
stays with you
or a sandbox in if jay sandbox closes
down after a week
it there's a little limitation in aura 3
which is 50 000 nodes and 175 000
relationships but
i think for for any experienced
a user i guess this is probably not
enough but for uh for a test run for
exploration phase for giving uh a small
fraction of a bigger chunk of data a
world and see if if neo4j or graphs are
the right thing this is completely fine
and you do get neo4j bloom on top of it
as well so you can use visualization
with bloom
as well which you can look at today as
well and we exactly cool
that's good
so we have a look at that
yeah
today we look into stack overflow data
so michael picked a picture stack
overflow data set i i only know stack
overflow honestly
i don't know much more
so um maybe um
michael you can give us a few more
details about what what what to expect
yes so uh perhaps you can i can share my
screen so we'll switch over to my screen
yep
cool
so uh
every one of you who has been developing
and looking for answers in any
programming question or like libraries
or how to do abc
i think no one didn't come across that
old floor right so if anyone is
programming in any
language or christian library then um
you're
necessarily end up on the go flow so a
lot of nearby questions i get getting
asked if you go through so for instance
if you look here at the nearest j tag we
see we had in total almost 21 000
questions
okay
and all the time
so these are the news questions so if
you go to text neo4j or put in
square brackets neo4j into individual
search then you see all the
latest neo4j we can also get active or
bounty to or unanswered questions if you
want to help out a little bit with folks
then feel free to do that or ask your
own questions as well
and um
so basically
question answer side so if you look at
then
the antenna anatomy of an office signal
stegoflow question what does it look
like
so um first of all we have
a question right so someone asked a
question it has a title it has an url
it has upvotes on words it has
someone posted it
and there can be tags attached to um
across
the front since if i was uh cipher type
here i see all
the
questions take this
so you can have more than one
tag on a question as well
and uh the other thing that you also
what are the related texts this is
actually a question if you can also
answer them with james and that's one
that we want to look into
as well so what are the related tags to
certain
okay what else do we have we have um
answers so different people provided
answers to this question
they have also uploads downwards
they kind of all the comments
and
then there could be an accepted answer
as well right
so someone has uh so multiple people
have answered this question and one
answer got accepted here uh as well so
and this each of these answers has also
in
and post them
right so that's kind of the general
anatomy of a of a question in
the second floor so the answers don't
have extra tags or they don't have an
extra title that's all coming from the
main
question yeah as such
cool by the way if you have questions uh
during the uh session uh feel free to
ask them alex
can then call me i'll have forever yeah
totally yeah
yeah so hopefully um
what what can we do with this so first
of all we could all uh ask different
questions for instance what are top
answers
what are like questions for a certain
tag what are frequent questions in a a
time frame
um who has been uh
answering a lot of questions so kind of
quite straightforward things right but
then you can also do other interesting
things like for instance looking at the
tax do
multiple questions
repeatedly share text so for instance
does cipher always come with a neo4j tag
or what other attacks are coming with
site let me see here these related
questions or could check out
would be really good for answering a
certain question so we could say when
someone answered questions in the past
and look at the text of
questions
and i look for new unanswered questions
after these tasks so we could recommend
these questions to them
right but it could be consistent
questions
that you can look at
as such
so um
as usual we'll do a little bit of
modeling and then we look at the data
all right so we use arrows again our
favorite uh graph modeling app uh so if
you haven't seen it before arrows that
app gets you to
uh to the app you can either store the
data
in your local storage of your browser or
on
google drive
and it's pretty easy to use and
straightforward to you so we can get
going directly
so what did we have we said we have a
question right so
the question
uh
which has been asked
or posted by a person or user
user
all right so this user posted the
question
right so this is the wrong direction of
our arrow but it's not a problem because
we can just click onto those and then it
comes in the other direction
so the question also has some attributes
for instance we can say the question has
a title
which is a string
you can say it has a
created date
created which is a date time
we can have uh upwards for instance
which is an
integer
right so we have this kind of uh
attributes here and question would be
our uh our label as we can also turn
this into and
come on
question later
and then we can oops
you know
yeah okay uh and now we can uh use
something else for the caption for
instance a title often uh
sites for parameters like that would be
our title right
so what else do we have our users of
course put other questions as well right
so
we could say okay this user has also
posted another uh question fancy
[Music]
or an actual text
right and a bunch of other attributes
this means tags tags you would you would
put in a separate
in a separate note exactly
because they basically are external
entities that multiple questions can
share such right so something like a
title or a date time when something was
created or
but uh did the body of these questions
that but something like tracks this is
sometimes that's unique to the question
it stays with the question and something
that is more like
yeah okay
so for instance we can say our uh for
instance our tag is and we have another
tag
uh that's
uh
let's say
yeah
if i want to quick type software
right and this gets also
right
so and then uh of course questions can
have answers not every question has an
answer or answer
for instance if a question just got
asked they are most likely don't have an
answer yet
but what you can do is now to say okay
there are a bunch of answers for
a question
for instance uh use them
as our answer such a parameter system
and we can call this an
answer uh give us an answer label here
right
and
of course uh
so uh this um
answers
the question and you just want to point
the arrow in the other direction right
so this answer answers our question
okay
and of course um
someone has to have written the answer
as well right so we can just add a note
here
for another user
um
[Music]
let's say another user
we should probably turn this into an
and this is the user
right yeah and this is uh for instance
helena
helena answered
this question by writing her answer
so uh
post it or wrote or
whatever you want to
call this
so this is kind of the basic structure
of course you can add comments and other
things as well but this is kind of what
we want to look at
and if an answer is picked as a as the
one
should that be a property
so like
several uh
possibilities so um there could be
something like accepted answer so we
could say
an answer could you have an additional
label it's called accepted
um
this is one option
uh the other option
could be that you put a property on me
also that says accelerate
um
which is a boolean to a port right yeah
third option would be uh that there's an
actual and backwards relationship only
one for question
that's called accepted answer
okay
so and actually it depends a little bit
i'm not sure why the rendering is
[Music]
seems to have not
updated it looks like an older version
of error so perhaps my browser uh cached
this tool graphically
um
let's see
so there could be one that's an accepted
answer basically right so that's uh
there are three options here and
depending on
on your questions depending on your
needs uh each of them could be possible
right so the boolean property i would
probably not use
the
um accepted label it's a quick way of
finding accepted answers because the
labels are very easy for the database to
basically find out
and the accepted answers is uh it's
useful when you want to go especially
from questions to the single accepted
answer because there should only be one
answer
so other attributes that you have for
instance the user has of course stuff
like
a screen name
uh which is a string
and bio and anything like that and the
answer itself has of course
something like a text
which is a string and then uh
for instance what's upload
uploads to downloads and favorites
this is basically our basic data model
that we can
look at
right
the interesting bit here is of course
that these tags have not just one arc
question that they're connected to so
of course they attacked to
flip around the relationship direction
so
or actually
i think it would go from from the
question to the hack so
this this question is tagged with cipher
and it's tagged with new j
and you can have as many texts yes as
you want and then of course other
questions can also be tagged with one or
more of those or zero or more of these
texts as well right so we could also
then say okay this question over here
is not typed with cipher but only with
neo4j for instance
or with javascript or whatever you want
to take
right
so
and it's quite nice um of course we
don't really want to go and enter all
the data ourselves right so we want to
kind of automating the import so there
are two
uh two ways of doing that so one is
um a quick way of getting access to a
subset of the data
um which is what you will look into
today the other way is
i think
monthly overflow to
um to the internet archive
and so you basically can ever get
months you can get it go through done
with all these all the answers all the
people all the votes all the comments
and everything in one gigantic file
as such
uh which is
then like has lots of fun you can
process them and import them into neo4j
that's actually
10 million
so there's a blog post from a while ago
uh where we've done this and we've done
it several times ever since i also have
a
good type repository with a converter
that takes the the format from stack
offer it turns it into csv
can import your whole
file basically
uh with the batch importer 15
dump
uh sorry with the buy computer
right so it's
quite a lot of data and it's a little
bit a little bit too big yeah
but if you take one of the
aura pro instances you could put it
into the
database as well
so but what we want to look at today is
basically an um
rest api that as the gopher has
and you can basically get uh the
questions appear in point
and then say
uh i want to get 100 questions in this
sort order with this tag
from stack of flow and then it gets you
in this information okay so if you look
at this
in the items
for each question you have the text of
the question the person who posted the
question
all these counts that i mentioned common
core delete account
is answered flag new code favorite
column download upwards answers scores
and so on activity dates
sharing and the body basically right so
each question has busy within and then
some question has also answers
uh
let's see
if you find one with answers
[Music]
this one here uh this one has also
answers and then for each answer you
have the comments on the answer the body
of the answer the person who posted the
answer
and then um
that's it basically on all the other
details right so it's a really nice
structure
in the json that you can take and turn
into a graph
and fortunately uh or free
but if you haven't done it yet you can
basically go to aura
and
say
you log in and you say i create a
database i create an oracle database and
call it
overflow
but i've set this at the beginning
and then you say create free database
you need to copy the password somewhere
and then say i have saved this password
oops
i've saved
this one
and then it creates your database but it
takes a few minutes so i have
pre-created that and so that you can get
going
already
so we have an empty neo4j database here
so there's nothing there
and
we can now import this data from the
rest endpoint to json into neo4j
and what we're going to use is
a user-defined function called or
user-friend procedure called
apoc.load.json
that can access uh rest urls or
any kind of url that returns json
and then you can get the information
into a new chain
so as an
example uh by the way uh
we probably post this uh so basically if
you just google
apoc
load json stack overflow
then it gets you directly
to the page here
yeah okay
right so it's pretty straightforward
to find and then there's here on the
right side the input from the floor and
then here it is a page that i'm using
yes right okay
okay cool and here's an example uh we
can copy this to the keyboard and build
it a little bit by looking at it
so what you do here is this is the url
that i just showed you right so
100
questions tagged with neo4j so if you
want to introduce if you're interested
in another tag let's say react or
graphql
or kubernetes or so feel free to change
the stack to whatever you want
and uh this is our url
and we pass this to apoc low json
and what apoc json returns actually
you can actually look at this let me
make it a little bit smaller so we see
more only like let's say
three
three questions instead of 100
and
if you just look at what does this
value look like that you're getting back
and if you look at this
so it's maybe just in neo4js
structure so this is kind of
maps with keys and values and these
component lists and the lists can have
again maps and keep your values and
literal values and strings in order to
do that so it's basically exactly the
same as you're seeing here in the in
browser as well
so and this is what you can work with
right so we can now take for instance
this owner field here and turn it into a
user in our database and you can take
the title of the question
[Music]
uh
somewhere it says title
oh there's title answers
somewhere title um
here
title
and turn this into our title for our
question and you can take the great date
and
uh our question timestamp
which is the numeric timestamp here and
turn it into our uh
creation date right
so we basically take these things out of
this tree structure in the json and turn
it into our graph structure
so
an example of this is so we get our
value and then value has items as we've
seen here right so uh
really has items
and for each item we want to do
something for instance we say here we
unwind each of these items so this list
here
items is a list stood in the rows so
each of these questions
which is in the items turns into a row
and then we just return the item title
um the item owner
so the person
with all the detail
the creation date and the other keys of
this item so what are the other like
keys of this map structure for the first
few items right
we just take this list turn it into rows
from a list and two rows and then for
each row we just select a bunch of stuff
that your potential
i guess you need to
up the number again 200.
oh for this example it's okay
yeah okay we'll do it later yeah so it's
only three that we get back right so
good point
let's the attention so we only get three
that could expect because you said you
wanted to have only three
but yeah you limited to five so it
doesn't match yeah
so we have our title so which is kind of
the
questions that you could see here in the
in the secondary eye as well so it's
really live data so you can pull live
data from the gopro which is really cool
uh the creation date is this uh epoch
time stem six seconds since um
1970
[Music]
[Laughter]
then we started all general first
that's what the reason
something wrong where you get actually
january 1st 1970 as the date oftentimes
ah i see
right actually you can test it in neo4j
as well you can say
time
of
epoch
seconds
zero
and it returns january 1st
1970
at midnight
so this is the first
entry in the
uh
in this time frame basically
exactly and then um
exactly that's the beginning of time
i was
not even born then
it was five more years after at this
point
um
and then the other thing that you get is
the owner and you see that the owners
again a nested structure so for instance
if you are only interested in certain
aspects of your own we can also just
extract the information that we need or
want right
and then all the other keys we have uh
for this um for this question we have to
oh no we have comment count the link
locked up
and so on upwards downwards question
ideas uh question id is actually quite
important because that's our unique key
for the question
should probably have added this to our
model
so we should probably say
our question has
an identity yeah
as um
it's a string
because i'm not sure if it's
one you know
i think it might be
only but
to be honest if that you can also turn
it into a string
and a bunch of other things right so
that before is in the ui or in the
json already so and so if you want to
because in the in the past when in these
sessions we always used csv import so
having done this
it looks very much now
similar to what we did previously with
the csv import so we basically we
we take away the the json a little bit
and then make it so that these
individual fields become
can become nodes like you said before in
a similar fashion
to the csv import we used used to do
before exactly so we basically
deconstruct the json a little bit and
flatten it out into individual rows so
imagine this owner field we don't want
to have the json here but we want to
have the other details so we could say
let's say we get the user id and the
display name
so we would say item owner user id and
item dot owner dot
display name right
so and if i run this
and then we could also for instance
imagine you were also interested in the
um
let's say
into the share link of the question
right so we could say item.chair
link
and if we rerun this then we see that
it's busy flattened out completely like
a json right so then it's completely
flat
and that's something that you can also
do then right so that's
so and because it's live data we can
basically take the data live from signal
flow and turn it into a into
our graph
and now it's basically the same as we've
done before
we basically create
nodes and relationships based on our
model right so we would create
a node for the question where we use the
question id and the question title
uh we would have created a second node
for the user that will use the item
owner user id
as the id and the item owner display
name as
their name
and and so on
right so for to just do this small
example here
what we can do is we can basically take
these and say
uh
we
use merge here so that means even if you
run this twice it will not create the
data twice so it will only create it at
once right so we create a question like
we said
and we want to have the id as the item
dot question id
and then after we created a question we
can then set for instance q dot title
equals item
or title so we said the question title
i'll just leave the other properties for
now
and then
we do the same for the user who posted
this question so let's say the owner
which is the user
and their id is
not a question id of course but it's
item dot owner dot
user id so we reach into the structure
and pull out
the
user id and use this as our
id from user
and last thing we do is we
create a relationship so just use a
posted
this question
and then we could also add
like we did with the the question we
could add a um
instead of just having these ids we can
also have a username
yes exactly so we would say uh o.name
owner name is
the item.owner.display
name
right
so we can choose our own
property names you don't need to
use the one that stick over users we can
use our owns
so let me say this user posted this
question so we create a question for
each row
and then a user if it doesn't exist it
runs of course the same user could have
posted already previous questions and
that uses um
node might already exist and then we
just state the fact that this user
posted also this question
and then what we can do in the end we
can just return our newly created nodes
in relationships
uh
q
uh
o
and let's call this relation r
and uh then we can even remove our limit
and if i run this and i have not
misspelled anything which i hope i
didn't
then we should get
three
uh three sets yeah
three sets always you can see the blue
ones are the users um the orange one
it's not the questions and the
relationships in between right
so now if you change our page size as
you said from
three to one hundred again
and then
now you get a hundred yeah this should
be fine we get 100 right yeah which is
uh you can actually
now we see that a couple users have
asked more questions than just one
exactly right so that's that's really uh
nice already something like a structure
to see right so yes
obviously already
certain users
had for instance they started out using
neo4j and they had a bunch of questions
yeah this one right there
one person here who was very yeah
in the last one last 100 questions they
already asked how much is it
seven yeah seven questions yeah pretty
clearly uh
politic uh prolific
oscar of questions
right
so and now we can continue with our data
structure right so now we can say okay
each of these questions also has tags as
we've seen in our
api here right so so we could now do the
same here and say okay
we also want to
uh for each our question
we want to take the text and create
entries for each tag right so then this
one says unwind
item dot text
as
tag so this is kind of taking this list
of
a list of tags
and turning
each of them into a row again
so there are two options actually
unrolling them for each let's look at
one first and then you can look at page
as well unwind item text as tag so each
tag has
it's business just a string right so we
don't need to do any adopt things
anymore so it's just yeah
and um
and now we can basically say
we merge our
tag
with the
name
the one that we got from the json
and then we also say uh this question is
checked
with stack
right
so
so we return and then
uh
we're good so we can attack here
and then connect the question to this uh
okay
so the other ones you could
leave in there or change um change
things but because it's
all these operations are either
important so they would just
not change anything if the data is
already there uh we can also just leave
them in there it's up to us
so it's you can incrementally build up
something like this as well uh
oops
and it complains there's some with
required between merge and unwind so
it says here and in this
before this unwind
it once in this
so you can just say ref star
so sometimes sci-fi is
certain requirements in inquiry and then
you choose complete because you already
have a unwind at the top you need
this no it's just because merge is in
right operation and then unwind starts a
new block for a new clay point
so this is just something like a
boundary between tripods
but
in this particular case it doesn't
say about uh
again and then you want to see
how we create all the tags
now we create all the text and all the
other stuff again and something that
actually happens here is now because you
have already all this data in your
database so we have 184 questions and
one-on-one relationships
it actually takes longer than before
right so because the database was empty
before but now it actually has to check
for each question and each user in each
check does this one already exist so
actually
oops
that's an interesting one
okay so it complained that it needs more
memory than it has available
so our aura
database here
should actually now see how many nodes
and relationships it also has
that's interesting
it takes sometimes a little bit longer
yeah to update so it has i think a
gigabyte of total memory so it shares
this between like
system stuff
but i think uh
when if you like can probably avoid this
by just looking at the um
at the indexes first um so let's see um
i'll try this first
i don't want to change it for now so let
me just
create and constraint
and what i wanted to say actually is to
say um basically because it has to check
each of these things does the question
already exist just use already it's the
track already exist
it takes longer than more data already
in the database
yeah
so
so we just created
three constraints one is on question
a search q dot id
so which is a unique constraint or
question
okay then we do the same for our user
right and in tag we didn't call it id we
called it name
so if you have um
multiple keys that from
a multiple property when you key then
you
have also a syntax for that um which is
called node d
so if you're interested in these kind of
things there's this rash card
which has all these syntax things in
there and uh so for instance
create constraint
you see this syntax here
such
so we created our three constraints
and if i now run uh schema the schema
command colon schema command it shows me
our constraints basically that have been
created
together with some
basic
system
constraints and so on
okay
so now
if i rerun this
let's see if the memory is still not
enough or if it actually finishes this
that's one other thing that we can do
actually which is you can make these set
operations also conditional so that
means
if the question already exists we don't
need to set a title again if the user
already exists we don't set the name
again and and so on right so
yes the merge operation has this on
concrete
clause
so it would only set the title when it's
really created
more
right
so it still doesn't like us so we'll
probably
take a few
let's say half
let's just pick 15 okay we did our 50
and um
then we can do the other ones as well
so if you look at this now
oops
if you look at this now you see
our questions
and then we also see a text here all
right so we see from this neo4j attack
which is pretty connected the cipher
text which is pretty connected
you see the kind of kobe tags we see
graphql tests
grand stack
and so on python
so this kind of helps us now to answer
some of our questions already right so
what i'm gonna do is
um
we can
now we have a page size of 50 so this
was the 51st questions
and now we can say um
for instance
page equals one and page equals two so
the second page we can just run
one page after another basically uh to
import more data
right so you see okay uh kind of just
adds more data here on the npr so you
can also see oh i guess because you
added this this on create
um probably that helped a lot
it skips
right run it once or ran it once so it's
still
doing the merge there but um it's
so you see it's adding
more and more data here yeah you can
also automate this a little bit more but
um
not sure if you have the time today but
perhaps one of the next times you can
look into
apoc and what we can do with batched uh
data creation updates yeah that's a good
idea
so
now we created like four pages one two
three let's see let's do another one uh
let's create four pages of data
by the way you also see it if you
quickly to tip on the table view here
how many labels nodes
uh properties and
relationships have been
created so you also see how much data
was created for
for each run of the segments
right so we now have 500 nodes and 720
uh relationships both posted intact
relationships
we could for instance also say let's
look at an
attack
um
like for instance the python tag and
then we can say please expand this
python text so we would see all
questions tagged with python
and then we could say okay
if you pick one of these questions what
else have they been tapped with probably
neo4j right
because we've been looking for the
neighbor jpeg yeah
and cypher as well and as well okay yeah
make sense so
which now allows us to answer one of our
questions kind of what are related text
to another tag right so we for instance
that
we have attack so we find our first text
which is our
you know here we have
the psychic tab right
if i click on this iphone pack
uh it says
down here what are related text right
so let's see if we can compute something
similar in our graphic
space as well
so
here we found ark which is called cipher
right
you can just return it just to see that
this works
okay that's all single lonely search
type
and then you want to do is you basically
want to go from this architectural
questions and then look at each of those
questions and what
are the other tags
that have been
used with this three of these questions
right and then
sort them by frequency how frequently
they have been used
okay so we basically spell out this
pattern that we don't know just clicked
in the ui we can also spell this out
basically yeah we can say
okay this cipher tag
questions
so we are not really interested in
questions we just say that there's a
question in there right so
uh the question itself is not
interesting for us it's only interesting
for us basically
how many questions were there
so and then we um
say this has been
tagged this question has been tagged
with cell phones so we could leave off
the relationship type because we have to
detect here but
uh it's just good practice uh to edit
there because it's more expressive and
it's also
for larger layers
it gets faster by adding relationship
types as well
and then we have
two so this is again right so we have
basically what's the other text
for each ciphertext you find a question
and then what else is attached to this
question basically so it could be one
two three four other texts etc
so and what you're interested in is kind
of what what are the names of the tags
and how frequently do they occur and
this is where we use
aggregations
so the simplest way of doing this is
just to return the name of
t2 of course right
and how often did it show up in our
query so conestog
right
and then we just say
order
by
count star
descending
and then let's say let's look at the top
let's say five or ten led tags to
cellphone right
so in our four pages of data so the last
200 questions
we should now see
do you need to make sure that t1 is not
t2
that's something that cypher does
automatically so um basically to avoid
circular loops
right so otherwise you can if you have
larger patterns you couldn't get loops
it says every relationship in such a
pattern only occurs once so of course
the relationship to cipher is already
used up on this on the left side
basically it can't
come in on the right side here okay
again right so each relationship is
unique in a pattern to say so right so
if it's already been used somewhere in
the pattern
even for larger pattern that's true
right so if it's being used already
somewhere in the pattern then
it can't show up again as such
in a single pattern
you can actually look at this in a
second
let's just quickly look at the um
results so it says neo4j which is
obvious right so there's never a graph
here this is java graph python
parallel processing relationship and if
if you look at our
neo4j java apoc
python
so this looks at more data not just at
the last 200 questions but you see
you're getting these similar
similar results
here as well
right so we can do basically the same as
the stackoverflow ui does
to your question alex is if the
split is up into two matches
so if we also say match
first from the tag to the question and
then from the question again to text two
then we have two separate matches
this relationship here from cypher can
show up here again because these are
independent matches
right
it's only valid in a single pattern that
they can't
occur twice so here now actually the
cipher pattern itself i thought the
cipher attack itself should show up now
uh on top
right
obviously yeah
but if you
if you put this into one pattern then
cypher itself uh takes care of that uh
as well
that's good
yeah it's gone yeah
cool
and um this was the first question we
wanted to answer with today in our
database
and then the second question that we
wanted to answer is kind of this kind of
recommendation engine where you say hey
can we find people that have answered
questions with certain texts frequently
and can we find unanswered questions
with these tags and recommend them to
these people basically
fine
which is a little bit more involved
for two reasons so we need a little bit
more data in our database um
because we only have questions we only
have questions yes and the users that
ask this question in a text but we don't
have the answers yet yeah right and we
also don't have to users who posted
these answers
and we don't have the upvotes
or they accept it or something like that
yeah so we don't know yeah
if the answers are good i mean there
could be like five answers to a question
but four of them are
not really good and only one is good so
the one that is good should be
yeah
so we can
either um
look at the upwards because sometimes at
so instagram you have also something
that someone accepted an answer but then
someone else gave a different answer
later on
and which was actually better because
it's probably more recent or more
up-to-date or something like that but in
the original person who asked questions
didn't go back and i think i'm not even
sure if you can change it um
what you accept as an answer so it's
basically
and previous answer was accepted but a
newer answer might be better and so
looking up
at upwards as well is also sensible and
so and because
we don't have too much time left we can
just steal the statement to import all
the state
no you oh yeah here we go you were muted
for a second
you're
back okay
can you hear me i think my yes now i can
hear you yeah
now we can hear you
okay so yeah here we have actually all
in one right so we have
basically
our um
um so we have
our import that we just looked at we get
our question we set the title sharing
favorite column we set the text so this
one here uses for each and not unwind uh
so for each just busy
in one line what you do with unwinding
and multiple lines
and then for each of the answers
that he creates the answer to this
question
and then also
connects the answer the person who sent
the answer
and then you connect the uh
answer to the answer and then we have
this uh and then we also
put in useful answers
so the model is a little bit different
uh so what i quickly do is i'll just
quickly clean out the database
let's see if
um
because otherwise i would have to
fiddle around with all the things
um and now we can just steal our
statement here from from the box
and as i said we create our questions
uh we connect the text we connect the
answers and we
uh
the answers and the user will ask
questions as well
uh
to not get out of memory i'll just put
in
50 and
h1 yeah
okay let's see what happens running this
so now you see here it also pops up
answers
right
and also provided and answers and asked
and so the other relationship types are
here as well as fast let me just do
for the this
two pages
[Music]
so we now have 600 nodes and one
thousand relationships in here which
should be good enough for what we need
and now we can say okay what what are we
interested in you are interested in
questions
um
which
has
uh
answers
right and the answer was uh
provided by a person
which is our user
so this is step one that we are
interested in so what are questions that
um have been answered by users and the
other thing that you're interested in
this which text do these questions have
as well
[Music]
so
this would give us
kind of for each tag now we could say
who are the most common users that
answers with this
right so we could say now
return
tag
why do you separate these two with a
comma instead of doing two two times
matches that's because a difference i
could do two matches uh yeah both as
possible so
just want to do it into one pattern
so this is basically the same
yeah okay
so and then we just say
we return to tech name
and the user
name
and we again count them and say
count
[Music]
[Applause]
so this would give us only the globals
so kind of across all tags basically
who were the users that answered them
most frequently so this might be
the top answers across all attacks
basically right
for the time being this
should be good enough so we could also
do this
oops
is it called
display name sorry in this model
um
so we had um
and this in our model here for the new
jtag and the ciphertext affiliate
answered or provided the most answers
and then too much
for say for
again to march and david right
so now we could say okay
find me questions that don't have
um
[Music]
and then we can say
find me questions that uh
don't have any
answer
so we say
find me questions
actually let's start with those
questions they are not just
um
but here we can one with one of the new
features which is called and
um
just start
closed
um
so you're basically excluding a certain
pattern here
exactly i'm including this pattern so
this answer pattern should not exist
actually let's start with this
but what you're interested in is
basically
um i'll start question if you want to
get people for right
um
so we
you don't have answers here but you have
tags here right so
so we have cats
and um
and then for these tags you find
questions more questions
it's not our q0 that's our other
question
for these texts and find for these tags
who has been answering those
right yep
and then we basically can say okay
uh
for our q0 basically
um
we can
or for these texts from this
[Music]
the top question
or little latest question something like
that we just get it for the first few
questions
and then um
we basically get back uh who are the
people who are most likely to answer our
first uh questions
also
click on
give your title
uh tab.name
and
so if you run this
we see here
for this question for this tag
x this person would be most suitable
and
um
of course you want to aggregate this
overall
and it counts
basically across all texts
as such right so it doesn't do it for
neo4j inside the check but it could do
the sum of things right through the
account it could happen across all of
them
and so we say
oops
i also don't want to have each tech
every time
once
so you see
okay
these folks have been answering
across sci-fi and here today 82 times or
too much 37 times right so and then you
see for this question these folks would
be most likely uh to answer this one
right
and so on or um
for the next question
uh if pilot processing uh actually too
much has been most
most active
and you see with a few lines of cypher
there the first bit only determines
kind of whatever you want to answer and
then the second book
with two patterns basically instruments
who's most likely to give us a good
answer on that on those terms
and that's something you could apply
into any
uh exactly
we can develop this we could develop
this further we could say okay let's
let's let's add in upvotes to that to
that recommendation let's add an
accepted answer to that to that um to
that thing so it's
exactly so then we would also not just
count them but you would some for
instance the upwards uh
across these uh questions right or
something upwards and multiplied with
the weight based on if this answer was
accepted or not accepted for instance so
we can have a more complex
measure with our score so this count is
basically our score
and if you wanted to do more you know
realistic measure for the score then we
would uh conclude these other things
like uploads and
today i hope this was helpful and uh
interesting hope you enjoyed it i i
definitely do because i really like this
uh
exactly thank you michael for for
showing us through the through the the
queries and explaining to us how how
it's done
yeah maybe maybe we continue with this a
little bit
further and
you know add a little bit more flavor to
it next time and and then
could potentially even look at it in
bloom
but there was no time today for that
um
mariano mariano if you want to look into
that uh look at this ref card yes the
syntax for
creating indexes and constraints
exactly the ref card is a super helpful
helpful um thing for for anything i mean
you you can find every every
every
every query that is there with every
every um
term explain it and even a link to the
full the full list in the documentation
where you can uh read up on it how to
use it or best practice and an example
so it's it's really it's really a good
good piece
cool all right well with that i think
for today
and uh see you see you around uh next
time hope you enjoy uh this session and
um yeah
if you have an
data that you would like us to explore
please please let us know
thank you michael okay